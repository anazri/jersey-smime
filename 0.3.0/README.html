<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia at 2016-01-14 
 | Rendered using Apache Maven Fluido Skin 1.3.1
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="Date-Revision-yyyymmdd" content="20160114" />
    <meta http-equiv="Content-Language" content="en" />
    <title>Jersey S/MIME &#x2013; Jersey S/MIME</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.3.1.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />

      
    <script type="text/javascript" src="./js/apache-maven-fluido-1.3.1.min.js"></script>

    
                  </head>
        <body class="topBarDisabled">
          
    
    
            
    
        
    <a href="http://github.com/gini/jersey-smime">
      <img style="position: absolute; top: 0; right: 0; border: 0; z-index: 10000;"
        src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"
        alt="Fork me on GitHub">
    </a>
  
                
                    
    
        <div class="container-fluid">
          <div id="banner">
        <div class="pull-left">
                                <div id="bannerLeft">
                <h2>Jersey S/MIME</h2>
                </div>
                      </div>
        <div class="pull-right">  </div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
                
                    
                  <li id="publishDate">Last Published: 2016-01-14
                      <span class="divider">|</span>
                   </li>
                  <li id="projectVersion">Version: 0.3.0
                      </li>
                      
                
                    
      
                            </ul>
      </div>

            
      <div class="row-fluid">
        <div id="leftColumn" class="span3">
          <div class="well sidebar-nav">
                
                    
                <ul class="nav nav-list">
                    <li class="nav-header">Overview</li>
                              
      <li class="active">
  
            <a href="#"><i class="none"></i>Readme</a>
          </li>
                
      <li>
  
                          <a href="CHANGELOG.html" title="Changelog">
          <i class="none"></i>
        Changelog</a>
            </li>
                              <li class="nav-header">Project Documentation</li>
                                                                                                                                                                                                                                                                                      
      <li>
  
                          <a href="project-info.html" title="Project Information">
          <i class="icon-chevron-right"></i>
        Project Information</a>
                  </li>
                                                                                    
      <li>
  
                          <a href="project-reports.html" title="Project Reports">
          <i class="icon-chevron-right"></i>
        Project Reports</a>
                  </li>
            </ul>
                
                    
                
          <hr />

           <div id="poweredBy">
                            <div class="clear"></div>
                            <div class="clear"></div>
                            <div class="clear"></div>
                            <div class="clear"></div>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
                  </div>
          </div>
        </div>
        
                
        <div id="bodyColumn"  class="span9" >
                                  
            <h1>Jersey S/MIME</h1>
<p><a class="externalLink" href="https://travis-ci.org/gini/jersey-smime"><img src="https://secure.travis-ci.org/gini/jersey-smime.png?branch=master" alt="Build Status" /></a> <a class="externalLink" href="https://coveralls.io/r/gini/jersey-smime"><img src="https://img.shields.io/coveralls/gini/jersey-smime.svg" alt="Coverage Status" /></a></p>
<p>Jersey S/MIME is a port of the S/MIME functionality in <tt>resteasy-security</tt> to the Jersey framework.</p>
<p>S/MIME (Secure/Multipurpose Internet Mail Extensions) is a standard for public key encryption and signing of MIME data. MIME data being a set of headers and a message body. It&#x2019;s most often seen in the email world when somebody wants to encrypt and/or sign an email message they are sending across the Internet. It can also be used for HTTP requests as well which is what the Jersey integration with S/MIME is all about. Jersey S/MIME allows you to easily encrypt and/or sign an email message using the S/MIME standard.</p>
<div class="section">
<h2><a name="Maven_Artifacts"></a>Maven Artifacts</h2>
<p>You must include the jersey-crypto project to use the S/MIME framework.</p>

<div class="source">
<div class="source">
<pre>&lt;dependency&gt;
    &lt;groupId&gt;net.gini&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-smime&lt;/artifactId&gt;
    &lt;version&gt;0.3.0&lt;/version&gt;
&lt;/dependency&gt;
</pre></div></div></div>
<div class="section">
<h2><a name="Usage"></a>Usage</h2>
<div class="section">
<h3><a name="Message_Body_Encryption"></a>Message Body Encryption</h3>
<p>While HTTPS is used to encrypt the entire HTTP message, S/MIME encryption is used solely for the message body of the HTTP request or response. This is very useful if you have a representation that may be forwarded by multiple parties and you want to protect the message from prying eyes as it travels across the network. Jersey S/MIME has two different interfaces for encrypting message bodies. One for output, one for input. If your client or server wants to send an HTTP request or response with an encrypted body, it uses the <tt>net.gini.jersey.security.smime.EnvelopedOutput</tt> type. Encrypting a body also requires an X509 certificate which can be generated by the Java <tt>keytool</tt> command-line interface, or the <tt>openssl</tt> tool that comes installed on many OS&#x2019;s.</p>
<p>Here&#x2019;s an example of using the <tt>EnvelopedOutput</tt> interface:</p>

<div class="source">
<div class="source">
<pre>// server side   

@Path(&quot;encrypted&quot;)
@GET
public EnvelopedOutput getEncrypted() {
   Customer cust = new Customer();
   cust.setName(&quot;Bill&quot;);

   X509Certificate certificate = ...;
   EnvelopedOutput output = new EnvelopedOutput(cust, MediaType.APPLICATION_XML_TYPE);
   output.setCertificate(certificate);
   return output;
}


// client side

Client client = ClientBuilder.newClient();
X509Certificate cert = ...; 
Customer cust = new Customer();
cust.setName(&quot;Bill&quot;);
EnvelopedOutput output = new EnvelopedOutput(cust, &quot;application/xml&quot;);
output.setCertificate(cert);
Response res = client.target(&quot;http://localhost:9095/smime/encrypted&quot;).request().post(Entity.entity(output, &quot;application/pkcs7-mime&quot;));
</pre></div></div>
<p>An <tt>EnvelopedOutput</tt> instance is created passing in the entity you want to marshal and the media type you want to marshal it into. So in this example, we&#x2019;re taking a Customer class and marshalling it into XML before we encrypt it. Jersey will then encrypt the <tt>EnvelopedOutput</tt> using the BouncyCastle framework&#x2019;s S/MIME integration. The output is a Base64 encoding and would look something like this:</p>

<div class="source">
<div class="source">
<pre>Content-Type: application/pkcs7-mime; smime-type=enveloped-data; name=&quot;smime.p7m&quot;
Content-Transfer-Encoding: base64
Content-Disposition: attachment; filename=&quot;smime.p7m&quot;

MIAGCSqGSIb3DQEHA6CAMIACAQAxgewwgekCAQAwUjBFMQswCQYDVQQGEwJBVTETMBEGA1UECBMK
U29tZS1TdGF0ZTEhMB8GA1UEChMYSW50ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkAgkA7oW81OriflAw
DQYJKoZIhvcNAQEBBQAEgYCfnqPK/O34DFl2p2zm+xZQ6R+94BqZHdtEWQN2evrcgtAng+f2ltIL
xr/PiK+8bE8wDO5GuCg+k92uYp2rLKlZ5BxCGb8tRM4kYC9sHbH2dPaqzUBhMxjgWdMCX6Q7E130
u9MdGcP74Ogwj8fNl3lD4sx/0k02/QwgaukeY7uNHzCABgkqhkiG9w0BBwEwFAYIKoZIhvcNAwcE
CDRozFLsPnSgoIAEQHmqjSKAWlQbuGQL9w4nKw4l+44WgTjKf7mGWZvYY8tOCcdmhDxRSM1Ly682
Imt+LTZf0LXzuFGTsCGOUo742N8AAAAAAAAAAAAA
</pre></div></div>
<p>Decrypting an S/MIME encrypted message requires using the <tt>net.gini.jersey.security.smime.EnvelopedInput</tt> interface. You also need both the private key and <tt>X509Certificate</tt> used to encrypt the message. Here&#x2019;s an example:</p>

<div class="source">
<div class="source">
<pre>// server side

@Path(&quot;encrypted&quot;)
@POST
public void postEncrypted(EnvelopedInput&lt;Customer&gt; input) {
    PrivateKey privateKey = ...;
    X509Certificate certificate = ...;
    Customer cust = input.getEntity(privateKey, certificate);
}


// client side

Client client = ClientBuilder.newClient();
Response response = client.target(&quot;http://localhost:9095/smime/encrypted&quot;).request().get();
EnvelopedInput input = response.readEntity(EnvelopedInput.class);
Customer cust = (Customer)input.getEntity(Customer.class, privateKey, cert);
</pre></div></div>
<p>Both examples simply call the <tt>getEntity()</tt> method passing in the <tt>PrivateKey</tt> and <tt>X509Certificate</tt> instances requires to decrypt the message. On the server side, a generic is used with <tt>EnvelopedInput</tt> to specify the type to marshal to. On the server side this information is passed as a parameter to <tt>getEntity()</tt>. The message is in MIME format: a <tt>Content-Type</tt> header and body, so the <tt>EnvelopedInput</tt> class now has everything it needs to know to both decrypt and unmarshall the entity.</p></div>
<div class="section">
<h3><a name="Message_Body_Signing"></a>Message Body Signing</h3>
<p>S/MIME also allows you to digitally sign a message. It uses the <tt>multipart/signed</tt> data format which is a multipart message that contains the entity and the digital signature.</p>
<p>Jersey S/MIME has two different interfaces for creating a <tt>multipart/signed</tt> message. One for input, one for output. If your client or server wants to send an HTTP request or response with an <tt>multipart/signed</tt> body, it uses the <tt>net.gini.jersey.security.smime.SignedOutput</tt> type. This type requires both the <tt>PrivateKey</tt> and <tt>X509Certificate</tt> to create the signature. Here&#x2019;s an example of signing an entity and sending a <tt>multipart/signed</tt> entity.</p>

<div class="source">
<div class="source">
<pre>// server-side

@Path(&quot;signed&quot;)
@GET
public SignedOutput getSigned() {
    Customer cust = new Customer();
    cust.setName(&quot;Bill&quot;);

    SignedOutput output = new SignedOutput(cust, MediaType.APPLICATION_XML_TYPE);
    output.setPrivateKey(privateKey);
    output.setCertificate(certificate);
    return output;
}


// client side

Client client = ClientBuilder.newClient();
Customer cust = new Customer();
cust.setName(&quot;Bill&quot;);
SignedOutput output = new SignedOutput(cust, &quot;application/xml&quot;);
output.setPrivateKey(privateKey);
output.setCertificate(cert);
Response res = client.target(&quot;http://localhost:9095/smime/signed&quot;).request().post(Entity.entity(output, &quot;multipart/signed&quot;));
</pre></div></div>
<p>An <tt>SignedOutput</tt> instance is created passing in the entity you want to marshal and the media type you want to marshal it into. So in this example, we&#x2019;re taking a <tt>Customer</tt> class and marshalling it into XML before we sign it. Jersey will then sign the <tt>SignedOutput</tt> using the BouncyCastle framework&#x2019;s S/MIME integration. The output would look something like this:</p>

<div class="source">
<div class="source">
<pre>Content-Type: multipart/signed; protocol=&quot;application/pkcs7-signature&quot;; micalg=sha1;  boundary=&quot;----=_Part_0_1083228271.1313024422098&quot;

------=_Part_0_1083228271.1313024422098
Content-Type: application/xml
Content-Transfer-Encoding: 7bit

&lt;customer name=&quot;bill&quot;/&gt;
------=_Part_0_1083228271.1313024422098
Content-Type: application/pkcs7-signature; name=smime.p7s; smime-type=signed-data
Content-Transfer-Encoding: base64
Content-Disposition: attachment; filename=&quot;smime.p7s&quot;
Content-Description: S/MIME Cryptographic Signature

MIAGCSqGSIb3DQEHAqCAMIACAQExCzAJBgUrDgMCGgUAMIAGCSqGSIb3DQEHAQAAMYIBVzCCAVMC
AQEwUjBFMQswCQYDVQQGEwJBVTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50ZXJu
ZXQgV2lkZ2l0cyBQdHkgTHRkAgkA7oW81OriflAwCQYFKw4DAhoFAKBdMBgGCSqGSIb3DQEJAzEL
BgkqhkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTExMDgxMTAxMDAyMlowIwYJKoZIhvcNAQkEMRYE
FH32BfR1l1vzDshtQvJrgvpGvjADMA0GCSqGSIb3DQEBAQUABIGAL3KVi3ul9cPRUMYcGgQmWtsZ
0bLbAldO+okrt8mQ87SrUv2LGkIJbEhGHsOlsgSU80/YumP+Q4lYsVanVfoI8GgQH3Iztp+Rce2c
y42f86ZypE7ueynI4HTPNHfr78EpyKGzWuZHW4yMo70LpXhk5RqfM9a/n4TEa9QuTU76atAAAAAA
AAA=
------=_Part_0_1083228271.1313024422098--
</pre></div></div>
<p>To unmarshal and verify a signed message requires using the <tt>net.gini.jersey.security.smime.SignedInput</tt> interface. You only need the <tt>X509Certificate</tt> to verify the message. Here&#x2019;s an example of unmarshalling and verifying a <tt>multipart/signed</tt> entity.</p>

<div class="source">
<div class="source">
<pre>// server side

@Path(&quot;signed&quot;)
@POST
public void postSigned(SignedInput&lt;Customer&gt; input) throws Exception {
    Customer cust = input.getEntity();
    if (!input.verify(certificate)) {
       throw new WebApplicationException(500);
    }
}


// client side

Client client = ClientBuilder.newClient();
Response response = client.target(&quot;http://localhost:9095/smime/signed&quot;).request().get();
SignedInput input = response.readEntity(SignedInput.class);
Customer cust = (Customer)input.getEntity(Customer.class)
input.verify(cert);
</pre></div></div></div></div>
<div class="section">
<h2><a name="Testing"></a>Testing</h2></div>
<div class="section">
<h2><a name="Warning"></a>Warning</h2>
<p>Be aware of using other than default Connector implementation. There is an issue handling HTTP headers in `<tt>WriterInterceptor</tt> or <tt>MessageBodyWriter&lt;T&gt;</tt>. If you need to change header fields do not use nor ApacheConnectorProvider nor GrizzlyConnectorProvider neither JettyConnectorProvider. On the other hand, in the default transport connector, there are some restrictions on the headers, that can be sent in the default configuration. Since the S/MIME protocol depends on the <tt>Content-Transfer-Encoding</tt> header, the restrictions have to be disabled:</p>

<div class="source">
<div class="source">
<pre>System.setProperty(&quot;sun.net.http.allowRestrictedHeaders&quot;, &quot;true&quot;);
</pre></div></div>
<p>See <a class="externalLink" href="https://jersey.java.net/nonav/documentation/2.22.1/user-guide.html#d0e4957">https://jersey.java.net/nonav/documentation/2.22.1/user-guide.html#d0e4957</a> for more information on these limitations.</p></div>
<div class="section">
<h2><a name="Contributors"></a>Contributors</h2>

<ul>
  
<li><a class="externalLink" href="https://github.com/rafaroca">Raffael Stein</a></li>
  
<li><a class="externalLink" href="https://github.com/nicolone">Nico v. Hoyningen-Huene</a></li>
</ul>
<p>If your name is missing, please let us know.</p></div>
<div class="section">
<h2><a name="License"></a>License</h2>
<p>This library is licensed under the Apache License, Version 2.0.</p>
<p>See <a class="externalLink" href="http://www.apache.org/licenses/LICENSE-2.0.html">http://www.apache.org/licenses/LICENSE-2.0.html</a> or the LICENSE file in this repository for the full license text.</p></div>
                  </div>
            </div>
          </div>

    <hr/>

    <footer>
            <div class="container-fluid">
                      <div class="row-fluid">
                              <p >Copyright &copy;                   2016.
          All rights reserved.      
                    
      </p>
        </div>

        
        
                </div>
    </footer>
        </body>
</html>
